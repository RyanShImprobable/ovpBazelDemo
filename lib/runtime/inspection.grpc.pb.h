// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: runtime/inspection.proto
// Original file comments:
// Copyright (c) 2016 Improbable Worlds Ltd. All Rights Reserved.
#ifndef GRPC_runtime_2finspection_2eproto__INCLUDED
#define GRPC_runtime_2finspection_2eproto__INCLUDED

#include "runtime/inspection.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace improbable {
namespace platform {
namespace runtime {

// A service which provides a way to inspect and modify the world being simulated.
// Any request to read-only data within the InspectionService is done via a GET, any modification to the deployment
// (be it an addition, edit or deletion) is done via a POST.
class InspectionService final {
 public:
  static constexpr char const* service_full_name() {
    return "improbable.platform.runtime.InspectionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Request information regarding a worker.
    virtual ::grpc::Status GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::improbable::platform::runtime::WorkerNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>> AsyncGetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>>(AsyncGetWorkerNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>> PrepareAsyncGetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>>(PrepareAsyncGetWorkerNodeRaw(context, request, cq));
    }
    // Kill a Worker from the Fabric side. It may return successfully even if the request failed.
    virtual ::grpc::Status DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::improbable::platform::runtime::DeleteWorkerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>> AsyncDeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>>(AsyncDeleteWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>> PrepareAsyncDeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>>(PrepareAsyncDeleteWorkerRaw(context, request, cq));
    }
    // Request detailed information about a specific worker.
    virtual ::grpc::Status GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>> AsyncGetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>>(AsyncGetWorkerDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>> PrepareAsyncGetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>>(PrepareAsyncGetWorkerDetailsRaw(context, request, cq));
    }
    // Request all interest configuration indexed by worker type.
    virtual ::grpc::Status GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::improbable::platform::runtime::GetWorkerInterestResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>> AsyncGetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>>(AsyncGetWorkerInterestConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>> PrepareAsyncGetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>>(PrepareAsyncGetWorkerInterestConfigRaw(context, request, cq));
    }
    // Kill entities from the Fabric side.
    virtual ::grpc::Status DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::improbable::platform::runtime::DeleteEntitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>> AsyncDeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>>(AsyncDeleteEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>> PrepareAsyncDeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>>(PrepareAsyncDeleteEntitiesRaw(context, request, cq));
    }
    // Unary heatmap request.
    virtual ::grpc::Status GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>> AsyncGetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>>(AsyncGetEntityHeatmapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>> PrepareAsyncGetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>>(PrepareAsyncGetEntityHeatmapRaw(context, request, cq));
    }
    // Request information for a single entity.
    virtual ::grpc::Status GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::improbable::platform::runtime::GetEntityDetailsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>> AsyncGetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>>(AsyncGetEntityDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>> PrepareAsyncGetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>>(PrepareAsyncGetEntityDetailsRaw(context, request, cq));
    }
    // Request information about the world structure.
    virtual ::grpc::Status GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::improbable::platform::runtime::GetWorldExtentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>> AsyncGetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>>(AsyncGetWorldExtentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>> PrepareAsyncGetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>>(PrepareAsyncGetWorldExtentsRaw(context, request, cq));
    }
    // Request information about chunks in the world.
    virtual ::grpc::Status GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::improbable::platform::runtime::GetChunksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>> AsyncGetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>>(AsyncGetChunksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>> PrepareAsyncGetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>>(PrepareAsyncGetChunksRaw(context, request, cq));
    }
    // Request information about all workers in the world.
    virtual ::grpc::Status GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::improbable::platform::runtime::GetAllWorkersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>> AsyncGetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>>(AsyncGetAllWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>> PrepareAsyncGetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>>(PrepareAsyncGetAllWorkersRaw(context, request, cq));
    }
    // Request the strategy for how components will be delegated.
    virtual ::grpc::Status GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>> AsyncGetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>>(AsyncGetLoadBalancingStrategyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>> PrepareAsyncGetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>>(PrepareAsyncGetLoadBalancingStrategyRaw(context, request, cq));
    }
    // Request the mapping of virtual worker ids in the strategy to worker ids.
    virtual ::grpc::Status GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>> AsyncGetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>>(AsyncGetVirtualWorkerMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>> PrepareAsyncGetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>>(PrepareAsyncGetVirtualWorkerMappingRaw(context, request, cq));
    }
    // Subscribe to a view of entities in the world that can be changed by sending subsequent queries.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> SubscribeToEntities(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(SubscribeToEntitiesRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> AsyncSubscribeToEntities(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(AsyncSubscribeToEntitiesRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> PrepareAsyncSubscribeToEntities(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(PrepareAsyncSubscribeToEntitiesRaw(context, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Request information regarding a worker.
      virtual void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Kill a Worker from the Fabric side. It may return successfully even if the request failed.
      virtual void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request detailed information about a specific worker.
      virtual void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request all interest configuration indexed by worker type.
      virtual void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Kill entities from the Fabric side.
      virtual void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Unary heatmap request.
      virtual void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request information for a single entity.
      virtual void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request information about the world structure.
      virtual void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request information about chunks in the world.
      virtual void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request information about all workers in the world.
      virtual void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request the strategy for how components will be delegated.
      virtual void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request the mapping of virtual worker ids in the strategy to worker ids.
      virtual void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to a view of entities in the world that can be changed by sending subsequent queries.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeToEntities(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery,::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* reactor) = 0;
      #else
      virtual void SubscribeToEntities(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery,::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>* AsyncGetWorkerNodeRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::WorkerNodeResponse>* PrepareAsyncGetWorkerNodeRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>* AsyncDeleteWorkerRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteWorkerResponse>* PrepareAsyncDeleteWorkerRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>* AsyncGetWorkerDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerDetailsResponse>* PrepareAsyncGetWorkerDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>* AsyncGetWorkerInterestConfigRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorkerInterestResponse>* PrepareAsyncGetWorkerInterestConfigRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>* AsyncDeleteEntitiesRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::DeleteEntitiesResponse>* PrepareAsyncDeleteEntitiesRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>* AsyncGetEntityHeatmapRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityHeatmapResponse>* PrepareAsyncGetEntityHeatmapRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>* AsyncGetEntityDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetEntityDetailsResponse>* PrepareAsyncGetEntityDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>* AsyncGetWorldExtentsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetWorldExtentsResponse>* PrepareAsyncGetWorldExtentsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>* AsyncGetChunksRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetChunksResponse>* PrepareAsyncGetChunksRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>* AsyncGetAllWorkersRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetAllWorkersResponse>* PrepareAsyncGetAllWorkersRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* AsyncGetLoadBalancingStrategyRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* PrepareAsyncGetLoadBalancingStrategyRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* AsyncGetVirtualWorkerMappingRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* PrepareAsyncGetVirtualWorkerMappingRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* SubscribeToEntitiesRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* AsyncSubscribeToEntitiesRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* PrepareAsyncSubscribeToEntitiesRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::improbable::platform::runtime::WorkerNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>> AsyncGetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>>(AsyncGetWorkerNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>> PrepareAsyncGetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>>(PrepareAsyncGetWorkerNodeRaw(context, request, cq));
    }
    ::grpc::Status DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::improbable::platform::runtime::DeleteWorkerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>> AsyncDeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>>(AsyncDeleteWorkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>> PrepareAsyncDeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>>(PrepareAsyncDeleteWorkerRaw(context, request, cq));
    }
    ::grpc::Status GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>> AsyncGetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>>(AsyncGetWorkerDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>> PrepareAsyncGetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>>(PrepareAsyncGetWorkerDetailsRaw(context, request, cq));
    }
    ::grpc::Status GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::improbable::platform::runtime::GetWorkerInterestResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>> AsyncGetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>>(AsyncGetWorkerInterestConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>> PrepareAsyncGetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>>(PrepareAsyncGetWorkerInterestConfigRaw(context, request, cq));
    }
    ::grpc::Status DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::improbable::platform::runtime::DeleteEntitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>> AsyncDeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>>(AsyncDeleteEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>> PrepareAsyncDeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>>(PrepareAsyncDeleteEntitiesRaw(context, request, cq));
    }
    ::grpc::Status GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>> AsyncGetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>>(AsyncGetEntityHeatmapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>> PrepareAsyncGetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>>(PrepareAsyncGetEntityHeatmapRaw(context, request, cq));
    }
    ::grpc::Status GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::improbable::platform::runtime::GetEntityDetailsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>> AsyncGetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>>(AsyncGetEntityDetailsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>> PrepareAsyncGetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>>(PrepareAsyncGetEntityDetailsRaw(context, request, cq));
    }
    ::grpc::Status GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::improbable::platform::runtime::GetWorldExtentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>> AsyncGetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>>(AsyncGetWorldExtentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>> PrepareAsyncGetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>>(PrepareAsyncGetWorldExtentsRaw(context, request, cq));
    }
    ::grpc::Status GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::improbable::platform::runtime::GetChunksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>> AsyncGetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>>(AsyncGetChunksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>> PrepareAsyncGetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>>(PrepareAsyncGetChunksRaw(context, request, cq));
    }
    ::grpc::Status GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::improbable::platform::runtime::GetAllWorkersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>> AsyncGetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>>(AsyncGetAllWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>> PrepareAsyncGetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>>(PrepareAsyncGetAllWorkersRaw(context, request, cq));
    }
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>> AsyncGetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>>(AsyncGetLoadBalancingStrategyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>> PrepareAsyncGetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>>(PrepareAsyncGetLoadBalancingStrategyRaw(context, request, cq));
    }
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>> AsyncGetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>>(AsyncGetVirtualWorkerMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>> PrepareAsyncGetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>>(PrepareAsyncGetVirtualWorkerMappingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> SubscribeToEntities(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(SubscribeToEntitiesRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> AsyncSubscribeToEntities(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(AsyncSubscribeToEntitiesRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>> PrepareAsyncSubscribeToEntities(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>>(PrepareAsyncSubscribeToEntitiesRaw(context, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorkerNode(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteWorker(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorkerDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorkerInterestConfig(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteEntities(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEntityHeatmap(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEntityDetails(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetWorldExtents(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetChunks(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAllWorkers(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLoadBalancingStrategy(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVirtualWorkerMapping(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeToEntities(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery,::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* reactor) override;
      #else
      void SubscribeToEntities(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery,::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>* AsyncGetWorkerNodeRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::WorkerNodeResponse>* PrepareAsyncGetWorkerNodeRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::WorkerNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>* AsyncDeleteWorkerRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteWorkerResponse>* PrepareAsyncDeleteWorkerRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>* AsyncGetWorkerDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerDetailsResponse>* PrepareAsyncGetWorkerDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>* AsyncGetWorkerInterestConfigRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorkerInterestResponse>* PrepareAsyncGetWorkerInterestConfigRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>* AsyncDeleteEntitiesRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::DeleteEntitiesResponse>* PrepareAsyncDeleteEntitiesRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>* AsyncGetEntityHeatmapRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityHeatmapResponse>* PrepareAsyncGetEntityHeatmapRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>* AsyncGetEntityDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetEntityDetailsResponse>* PrepareAsyncGetEntityDetailsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>* AsyncGetWorldExtentsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetWorldExtentsResponse>* PrepareAsyncGetWorldExtentsRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>* AsyncGetChunksRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetChunksResponse>* PrepareAsyncGetChunksRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetChunksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>* AsyncGetAllWorkersRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetAllWorkersResponse>* PrepareAsyncGetAllWorkersRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* AsyncGetLoadBalancingStrategyRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* PrepareAsyncGetLoadBalancingStrategyRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* AsyncGetVirtualWorkerMappingRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* PrepareAsyncGetVirtualWorkerMappingRaw(::grpc::ClientContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* SubscribeToEntitiesRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* AsyncSubscribeToEntitiesRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* PrepareAsyncSubscribeToEntitiesRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkerNode_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteWorker_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkerDetails_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkerInterestConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteEntities_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEntityHeatmap_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEntityDetails_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorldExtents_;
    const ::grpc::internal::RpcMethod rpcmethod_GetChunks_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllWorkers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLoadBalancingStrategy_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVirtualWorkerMapping_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeToEntities_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Request information regarding a worker.
    virtual ::grpc::Status GetWorkerNode(::grpc::ServerContext* context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response);
    // Kill a Worker from the Fabric side. It may return successfully even if the request failed.
    virtual ::grpc::Status DeleteWorker(::grpc::ServerContext* context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response);
    // Request detailed information about a specific worker.
    virtual ::grpc::Status GetWorkerDetails(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response);
    // Request all interest configuration indexed by worker type.
    virtual ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response);
    // Kill entities from the Fabric side.
    virtual ::grpc::Status DeleteEntities(::grpc::ServerContext* context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response);
    // Unary heatmap request.
    virtual ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response);
    // Request information for a single entity.
    virtual ::grpc::Status GetEntityDetails(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response);
    // Request information about the world structure.
    virtual ::grpc::Status GetWorldExtents(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response);
    // Request information about chunks in the world.
    virtual ::grpc::Status GetChunks(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response);
    // Request information about all workers in the world.
    virtual ::grpc::Status GetAllWorkers(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response);
    // Request the strategy for how components will be delegated.
    virtual ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response);
    // Request the mapping of virtual worker ids in the strategy to worker ids.
    virtual ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response);
    // Subscribe to a view of entities in the world that can be changed by sending subsequent queries.
    virtual ::grpc::Status SubscribeToEntities(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorkerNode() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerNode(::grpc::ServerContext* context, ::improbable::platform::runtime::WorkerNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::WorkerNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteWorker() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorker(::grpc::ServerContext* context, ::improbable::platform::runtime::DeleteWorkerRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::DeleteWorkerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorkerDetails() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerDetails(::grpc::ServerContext* context, ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetWorkerDetailsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorkerInterestConfig() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerInterestConfig(::grpc::ServerContext* context, ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetWorkerInterestResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteEntities() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteEntities(::grpc::ServerContext* context, ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::DeleteEntitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEntityHeatmap() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEntityHeatmap(::grpc::ServerContext* context, ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetEntityHeatmapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEntityDetails() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEntityDetails(::grpc::ServerContext* context, ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetEntityDetailsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWorldExtents() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorldExtents(::grpc::ServerContext* context, ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetWorldExtentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetChunks() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChunks(::grpc::ServerContext* context, ::improbable::platform::runtime::GetChunksRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetChunksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllWorkers() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllWorkers(::grpc::ServerContext* context, ::improbable::platform::runtime::GetAllWorkersRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetAllWorkersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLoadBalancingStrategy() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadBalancingStrategy(::grpc::ServerContext* context, ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVirtualWorkerMapping() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVirtualWorkerMapping(::grpc::ServerContext* context, ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::grpc::ServerAsyncResponseWriter< ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeToEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeToEntities() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SubscribeToEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEntities(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEntities(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(12, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetWorkerNode<WithAsyncMethod_DeleteWorker<WithAsyncMethod_GetWorkerDetails<WithAsyncMethod_GetWorkerInterestConfig<WithAsyncMethod_DeleteEntities<WithAsyncMethod_GetEntityHeatmap<WithAsyncMethod_GetEntityDetails<WithAsyncMethod_GetWorldExtents<WithAsyncMethod_GetChunks<WithAsyncMethod_GetAllWorkers<WithAsyncMethod_GetLoadBalancingStrategy<WithAsyncMethod_GetVirtualWorkerMapping<WithAsyncMethod_SubscribeToEntities<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkerNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::WorkerNodeRequest, ::improbable::platform::runtime::WorkerNodeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::WorkerNodeRequest* request, ::improbable::platform::runtime::WorkerNodeResponse* response) { return this->GetWorkerNode(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorkerNode(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::WorkerNodeRequest, ::improbable::platform::runtime::WorkerNodeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::WorkerNodeRequest, ::improbable::platform::runtime::WorkerNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerNode(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteWorker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::DeleteWorkerRequest, ::improbable::platform::runtime::DeleteWorkerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::DeleteWorkerRequest* request, ::improbable::platform::runtime::DeleteWorkerResponse* response) { return this->DeleteWorker(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteWorker(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::DeleteWorkerRequest, ::improbable::platform::runtime::DeleteWorkerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::DeleteWorkerRequest, ::improbable::platform::runtime::DeleteWorkerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkerDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorkerDetailsRequest, ::improbable::platform::runtime::GetWorkerDetailsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetWorkerDetailsRequest* request, ::improbable::platform::runtime::GetWorkerDetailsResponse* response) { return this->GetWorkerDetails(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorkerDetails(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetWorkerDetailsRequest, ::improbable::platform::runtime::GetWorkerDetailsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorkerDetailsRequest, ::improbable::platform::runtime::GetWorkerDetailsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWorkerInterestConfig() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorkerInterestRequest, ::improbable::platform::runtime::GetWorkerInterestResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetWorkerInterestRequest* request, ::improbable::platform::runtime::GetWorkerInterestResponse* response) { return this->GetWorkerInterestConfig(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorkerInterestConfig(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetWorkerInterestRequest, ::improbable::platform::runtime::GetWorkerInterestResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorkerInterestRequest, ::improbable::platform::runtime::GetWorkerInterestResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerInterestConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerInterestConfig(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteEntities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::DeleteEntitiesRequest, ::improbable::platform::runtime::DeleteEntitiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::DeleteEntitiesRequest* request, ::improbable::platform::runtime::DeleteEntitiesResponse* response) { return this->DeleteEntities(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteEntities(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::DeleteEntitiesRequest, ::improbable::platform::runtime::DeleteEntitiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::DeleteEntitiesRequest, ::improbable::platform::runtime::DeleteEntitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteEntities(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteEntities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEntityHeatmap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetEntityHeatmapRequest, ::improbable::platform::runtime::GetEntityHeatmapResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetEntityHeatmapRequest* request, ::improbable::platform::runtime::GetEntityHeatmapResponse* response) { return this->GetEntityHeatmap(context, request, response); }));}
    void SetMessageAllocatorFor_GetEntityHeatmap(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetEntityHeatmapRequest, ::improbable::platform::runtime::GetEntityHeatmapResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetEntityHeatmapRequest, ::improbable::platform::runtime::GetEntityHeatmapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEntityHeatmap(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEntityHeatmap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEntityDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetEntityDetailsRequest, ::improbable::platform::runtime::GetEntityDetailsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetEntityDetailsRequest* request, ::improbable::platform::runtime::GetEntityDetailsResponse* response) { return this->GetEntityDetails(context, request, response); }));}
    void SetMessageAllocatorFor_GetEntityDetails(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetEntityDetailsRequest, ::improbable::platform::runtime::GetEntityDetailsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetEntityDetailsRequest, ::improbable::platform::runtime::GetEntityDetailsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEntityDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEntityDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetWorldExtents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorldExtentsRequest, ::improbable::platform::runtime::GetWorldExtentsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetWorldExtentsRequest* request, ::improbable::platform::runtime::GetWorldExtentsResponse* response) { return this->GetWorldExtents(context, request, response); }));}
    void SetMessageAllocatorFor_GetWorldExtents(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetWorldExtentsRequest, ::improbable::platform::runtime::GetWorldExtentsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetWorldExtentsRequest, ::improbable::platform::runtime::GetWorldExtentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorldExtents(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorldExtents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetChunks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetChunksRequest, ::improbable::platform::runtime::GetChunksResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetChunksRequest* request, ::improbable::platform::runtime::GetChunksResponse* response) { return this->GetChunks(context, request, response); }));}
    void SetMessageAllocatorFor_GetChunks(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetChunksRequest, ::improbable::platform::runtime::GetChunksResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetChunksRequest, ::improbable::platform::runtime::GetChunksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChunks(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChunks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAllWorkers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetAllWorkersRequest, ::improbable::platform::runtime::GetAllWorkersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetAllWorkersRequest* request, ::improbable::platform::runtime::GetAllWorkersResponse* response) { return this->GetAllWorkers(context, request, response); }));}
    void SetMessageAllocatorFor_GetAllWorkers(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetAllWorkersRequest, ::improbable::platform::runtime::GetAllWorkersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetAllWorkersRequest, ::improbable::platform::runtime::GetAllWorkersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllWorkers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLoadBalancingStrategy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetLoadBalancingStrategyRequest, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* request, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* response) { return this->GetLoadBalancingStrategy(context, request, response); }));}
    void SetMessageAllocatorFor_GetLoadBalancingStrategy(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetLoadBalancingStrategyRequest, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetLoadBalancingStrategyRequest, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLoadBalancingStrategy(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLoadBalancingStrategy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVirtualWorkerMapping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetVirtualWorkerMappingRequest, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* request, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* response) { return this->GetVirtualWorkerMapping(context, request, response); }));}
    void SetMessageAllocatorFor_GetVirtualWorkerMapping(
        ::grpc::experimental::MessageAllocator< ::improbable::platform::runtime::GetVirtualWorkerMappingRequest, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::improbable::platform::runtime::GetVirtualWorkerMappingRequest, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVirtualWorkerMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVirtualWorkerMapping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeToEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeToEntities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackBidiHandler< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SubscribeToEntities(context); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeToEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEntities(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* SubscribeToEntities(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::improbable::platform::runtime::InspectionEntitySubscriptionQuery, ::improbable::platform::runtime::InspectionEntitySubscriptionResponse>* SubscribeToEntities(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetWorkerNode<ExperimentalWithCallbackMethod_DeleteWorker<ExperimentalWithCallbackMethod_GetWorkerDetails<ExperimentalWithCallbackMethod_GetWorkerInterestConfig<ExperimentalWithCallbackMethod_DeleteEntities<ExperimentalWithCallbackMethod_GetEntityHeatmap<ExperimentalWithCallbackMethod_GetEntityDetails<ExperimentalWithCallbackMethod_GetWorldExtents<ExperimentalWithCallbackMethod_GetChunks<ExperimentalWithCallbackMethod_GetAllWorkers<ExperimentalWithCallbackMethod_GetLoadBalancingStrategy<ExperimentalWithCallbackMethod_GetVirtualWorkerMapping<ExperimentalWithCallbackMethod_SubscribeToEntities<Service > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetWorkerNode<ExperimentalWithCallbackMethod_DeleteWorker<ExperimentalWithCallbackMethod_GetWorkerDetails<ExperimentalWithCallbackMethod_GetWorkerInterestConfig<ExperimentalWithCallbackMethod_DeleteEntities<ExperimentalWithCallbackMethod_GetEntityHeatmap<ExperimentalWithCallbackMethod_GetEntityDetails<ExperimentalWithCallbackMethod_GetWorldExtents<ExperimentalWithCallbackMethod_GetChunks<ExperimentalWithCallbackMethod_GetAllWorkers<ExperimentalWithCallbackMethod_GetLoadBalancingStrategy<ExperimentalWithCallbackMethod_GetVirtualWorkerMapping<ExperimentalWithCallbackMethod_SubscribeToEntities<Service > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorkerNode() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteWorker() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorkerDetails() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorkerInterestConfig() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteEntities() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEntityHeatmap() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEntityDetails() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWorldExtents() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetChunks() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllWorkers() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLoadBalancingStrategy() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVirtualWorkerMapping() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeToEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeToEntities() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SubscribeToEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEntities(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorkerNode() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteWorker() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteWorker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorkerDetails() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerDetails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorkerInterestConfig() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkerInterestConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteEntities() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteEntities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEntityHeatmap() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEntityHeatmap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEntityDetails() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEntityDetails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWorldExtents() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorldExtents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetChunks() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChunks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllWorkers() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllWorkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLoadBalancingStrategy() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLoadBalancingStrategy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVirtualWorkerMapping() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVirtualWorkerMapping(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeToEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeToEntities() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SubscribeToEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEntities(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEntities(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(12, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkerNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorkerNode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteWorker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteWorker(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteWorker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteWorker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkerDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorkerDetails(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorkerInterestConfig() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorkerInterestConfig(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorkerInterestConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorkerInterestConfig(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteEntities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteEntities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteEntities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteEntities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEntityHeatmap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEntityHeatmap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEntityHeatmap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEntityHeatmap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEntityDetails() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEntityDetails(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEntityDetails(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEntityDetails(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetWorldExtents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWorldExtents(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetWorldExtents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetWorldExtents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChunks() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetChunks(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetChunks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetChunks(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllWorkers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAllWorkers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAllWorkers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAllWorkers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLoadBalancingStrategy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLoadBalancingStrategy(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLoadBalancingStrategy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLoadBalancingStrategy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVirtualWorkerMapping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVirtualWorkerMapping(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVirtualWorkerMapping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVirtualWorkerMapping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeToEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeToEntities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->SubscribeToEntities(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeToEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEntities(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::improbable::platform::runtime::InspectionEntitySubscriptionResponse, ::improbable::platform::runtime::InspectionEntitySubscriptionQuery>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SubscribeToEntities(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* SubscribeToEntities(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkerNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorkerNode() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::WorkerNodeRequest, ::improbable::platform::runtime::WorkerNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::WorkerNodeRequest, ::improbable::platform::runtime::WorkerNodeResponse>* streamer) {
                       return this->StreamedGetWorkerNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorkerNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkerNode(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::WorkerNodeRequest* /*request*/, ::improbable::platform::runtime::WorkerNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkerNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::WorkerNodeRequest,::improbable::platform::runtime::WorkerNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteWorker() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::DeleteWorkerRequest, ::improbable::platform::runtime::DeleteWorkerResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::DeleteWorkerRequest, ::improbable::platform::runtime::DeleteWorkerResponse>* streamer) {
                       return this->StreamedDeleteWorker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteWorker(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteWorkerRequest* /*request*/, ::improbable::platform::runtime::DeleteWorkerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::DeleteWorkerRequest,::improbable::platform::runtime::DeleteWorkerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkerDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorkerDetails() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetWorkerDetailsRequest, ::improbable::platform::runtime::GetWorkerDetailsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetWorkerDetailsRequest, ::improbable::platform::runtime::GetWorkerDetailsResponse>* streamer) {
                       return this->StreamedGetWorkerDetails(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorkerDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkerDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerDetailsRequest* /*request*/, ::improbable::platform::runtime::GetWorkerDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkerDetails(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetWorkerDetailsRequest,::improbable::platform::runtime::GetWorkerDetailsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkerInterestConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorkerInterestConfig() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetWorkerInterestRequest, ::improbable::platform::runtime::GetWorkerInterestResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetWorkerInterestRequest, ::improbable::platform::runtime::GetWorkerInterestResponse>* streamer) {
                       return this->StreamedGetWorkerInterestConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorkerInterestConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkerInterestConfig(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorkerInterestRequest* /*request*/, ::improbable::platform::runtime::GetWorkerInterestResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkerInterestConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetWorkerInterestRequest,::improbable::platform::runtime::GetWorkerInterestResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteEntities() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::DeleteEntitiesRequest, ::improbable::platform::runtime::DeleteEntitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::DeleteEntitiesRequest, ::improbable::platform::runtime::DeleteEntitiesResponse>* streamer) {
                       return this->StreamedDeleteEntities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteEntities(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::DeleteEntitiesRequest* /*request*/, ::improbable::platform::runtime::DeleteEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteEntities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::DeleteEntitiesRequest,::improbable::platform::runtime::DeleteEntitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEntityHeatmap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEntityHeatmap() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetEntityHeatmapRequest, ::improbable::platform::runtime::GetEntityHeatmapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetEntityHeatmapRequest, ::improbable::platform::runtime::GetEntityHeatmapResponse>* streamer) {
                       return this->StreamedGetEntityHeatmap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEntityHeatmap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEntityHeatmap(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityHeatmapRequest* /*request*/, ::improbable::platform::runtime::GetEntityHeatmapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEntityHeatmap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetEntityHeatmapRequest,::improbable::platform::runtime::GetEntityHeatmapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEntityDetails : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEntityDetails() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetEntityDetailsRequest, ::improbable::platform::runtime::GetEntityDetailsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetEntityDetailsRequest, ::improbable::platform::runtime::GetEntityDetailsResponse>* streamer) {
                       return this->StreamedGetEntityDetails(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEntityDetails() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEntityDetails(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetEntityDetailsRequest* /*request*/, ::improbable::platform::runtime::GetEntityDetailsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEntityDetails(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetEntityDetailsRequest,::improbable::platform::runtime::GetEntityDetailsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorldExtents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWorldExtents() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetWorldExtentsRequest, ::improbable::platform::runtime::GetWorldExtentsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetWorldExtentsRequest, ::improbable::platform::runtime::GetWorldExtentsResponse>* streamer) {
                       return this->StreamedGetWorldExtents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWorldExtents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorldExtents(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetWorldExtentsRequest* /*request*/, ::improbable::platform::runtime::GetWorldExtentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorldExtents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetWorldExtentsRequest,::improbable::platform::runtime::GetWorldExtentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetChunks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetChunks() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetChunksRequest, ::improbable::platform::runtime::GetChunksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetChunksRequest, ::improbable::platform::runtime::GetChunksResponse>* streamer) {
                       return this->StreamedGetChunks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetChunks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChunks(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetChunksRequest* /*request*/, ::improbable::platform::runtime::GetChunksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetChunks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetChunksRequest,::improbable::platform::runtime::GetChunksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllWorkers() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetAllWorkersRequest, ::improbable::platform::runtime::GetAllWorkersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetAllWorkersRequest, ::improbable::platform::runtime::GetAllWorkersResponse>* streamer) {
                       return this->StreamedGetAllWorkers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAllWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllWorkers(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetAllWorkersRequest* /*request*/, ::improbable::platform::runtime::GetAllWorkersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllWorkers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetAllWorkersRequest,::improbable::platform::runtime::GetAllWorkersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLoadBalancingStrategy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLoadBalancingStrategy() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetLoadBalancingStrategyRequest, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetLoadBalancingStrategyRequest, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* streamer) {
                       return this->StreamedGetLoadBalancingStrategy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLoadBalancingStrategy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLoadBalancingStrategy(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetLoadBalancingStrategyRequest* /*request*/, ::improbable::platform::runtime::GetLoadBalancingStrategyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLoadBalancingStrategy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetLoadBalancingStrategyRequest,::improbable::platform::runtime::GetLoadBalancingStrategyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVirtualWorkerMapping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVirtualWorkerMapping() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::improbable::platform::runtime::GetVirtualWorkerMappingRequest, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::improbable::platform::runtime::GetVirtualWorkerMappingRequest, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* streamer) {
                       return this->StreamedGetVirtualWorkerMapping(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVirtualWorkerMapping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVirtualWorkerMapping(::grpc::ServerContext* /*context*/, const ::improbable::platform::runtime::GetVirtualWorkerMappingRequest* /*request*/, ::improbable::platform::runtime::GetVirtualWorkerMappingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVirtualWorkerMapping(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::improbable::platform::runtime::GetVirtualWorkerMappingRequest,::improbable::platform::runtime::GetVirtualWorkerMappingResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetWorkerNode<WithStreamedUnaryMethod_DeleteWorker<WithStreamedUnaryMethod_GetWorkerDetails<WithStreamedUnaryMethod_GetWorkerInterestConfig<WithStreamedUnaryMethod_DeleteEntities<WithStreamedUnaryMethod_GetEntityHeatmap<WithStreamedUnaryMethod_GetEntityDetails<WithStreamedUnaryMethod_GetWorldExtents<WithStreamedUnaryMethod_GetChunks<WithStreamedUnaryMethod_GetAllWorkers<WithStreamedUnaryMethod_GetLoadBalancingStrategy<WithStreamedUnaryMethod_GetVirtualWorkerMapping<Service > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetWorkerNode<WithStreamedUnaryMethod_DeleteWorker<WithStreamedUnaryMethod_GetWorkerDetails<WithStreamedUnaryMethod_GetWorkerInterestConfig<WithStreamedUnaryMethod_DeleteEntities<WithStreamedUnaryMethod_GetEntityHeatmap<WithStreamedUnaryMethod_GetEntityDetails<WithStreamedUnaryMethod_GetWorldExtents<WithStreamedUnaryMethod_GetChunks<WithStreamedUnaryMethod_GetAllWorkers<WithStreamedUnaryMethod_GetLoadBalancingStrategy<WithStreamedUnaryMethod_GetVirtualWorkerMapping<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace runtime
}  // namespace platform
}  // namespace improbable


#endif  // GRPC_runtime_2finspection_2eproto__INCLUDED
