// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: agones/allocation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_agones_2fallocation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_agones_2fallocation_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_agones_2fallocation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_agones_2fallocation_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_agones_2fallocation_2eproto;
namespace allocation {
class AllocationRequest;
class AllocationRequestDefaultTypeInternal;
extern AllocationRequestDefaultTypeInternal _AllocationRequest_default_instance_;
class AllocationResponse;
class AllocationResponseDefaultTypeInternal;
extern AllocationResponseDefaultTypeInternal _AllocationResponse_default_instance_;
class AllocationResponse_GameServerStatusPort;
class AllocationResponse_GameServerStatusPortDefaultTypeInternal;
extern AllocationResponse_GameServerStatusPortDefaultTypeInternal _AllocationResponse_GameServerStatusPort_default_instance_;
class LabelSelector;
class LabelSelectorDefaultTypeInternal;
extern LabelSelectorDefaultTypeInternal _LabelSelector_default_instance_;
class LabelSelector_MatchLabelsEntry_DoNotUse;
class LabelSelector_MatchLabelsEntry_DoNotUseDefaultTypeInternal;
extern LabelSelector_MatchLabelsEntry_DoNotUseDefaultTypeInternal _LabelSelector_MatchLabelsEntry_DoNotUse_default_instance_;
class MetaPatch;
class MetaPatchDefaultTypeInternal;
extern MetaPatchDefaultTypeInternal _MetaPatch_default_instance_;
class MetaPatch_AnnotationsEntry_DoNotUse;
class MetaPatch_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern MetaPatch_AnnotationsEntry_DoNotUseDefaultTypeInternal _MetaPatch_AnnotationsEntry_DoNotUse_default_instance_;
class MetaPatch_LabelsEntry_DoNotUse;
class MetaPatch_LabelsEntry_DoNotUseDefaultTypeInternal;
extern MetaPatch_LabelsEntry_DoNotUseDefaultTypeInternal _MetaPatch_LabelsEntry_DoNotUse_default_instance_;
class MultiClusterSetting;
class MultiClusterSettingDefaultTypeInternal;
extern MultiClusterSettingDefaultTypeInternal _MultiClusterSetting_default_instance_;
}  // namespace allocation
PROTOBUF_NAMESPACE_OPEN
template<> ::allocation::AllocationRequest* Arena::CreateMaybeMessage<::allocation::AllocationRequest>(Arena*);
template<> ::allocation::AllocationResponse* Arena::CreateMaybeMessage<::allocation::AllocationResponse>(Arena*);
template<> ::allocation::AllocationResponse_GameServerStatusPort* Arena::CreateMaybeMessage<::allocation::AllocationResponse_GameServerStatusPort>(Arena*);
template<> ::allocation::LabelSelector* Arena::CreateMaybeMessage<::allocation::LabelSelector>(Arena*);
template<> ::allocation::LabelSelector_MatchLabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::allocation::LabelSelector_MatchLabelsEntry_DoNotUse>(Arena*);
template<> ::allocation::MetaPatch* Arena::CreateMaybeMessage<::allocation::MetaPatch>(Arena*);
template<> ::allocation::MetaPatch_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::allocation::MetaPatch_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::allocation::MetaPatch_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::allocation::MetaPatch_LabelsEntry_DoNotUse>(Arena*);
template<> ::allocation::MultiClusterSetting* Arena::CreateMaybeMessage<::allocation::MultiClusterSetting>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace allocation {

enum AllocationRequest_SchedulingStrategy : int {
  AllocationRequest_SchedulingStrategy_Packed = 0,
  AllocationRequest_SchedulingStrategy_Distributed = 1,
  AllocationRequest_SchedulingStrategy_AllocationRequest_SchedulingStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AllocationRequest_SchedulingStrategy_AllocationRequest_SchedulingStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AllocationRequest_SchedulingStrategy_IsValid(int value);
constexpr AllocationRequest_SchedulingStrategy AllocationRequest_SchedulingStrategy_SchedulingStrategy_MIN = AllocationRequest_SchedulingStrategy_Packed;
constexpr AllocationRequest_SchedulingStrategy AllocationRequest_SchedulingStrategy_SchedulingStrategy_MAX = AllocationRequest_SchedulingStrategy_Distributed;
constexpr int AllocationRequest_SchedulingStrategy_SchedulingStrategy_ARRAYSIZE = AllocationRequest_SchedulingStrategy_SchedulingStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllocationRequest_SchedulingStrategy_descriptor();
template<typename T>
inline const std::string& AllocationRequest_SchedulingStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllocationRequest_SchedulingStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllocationRequest_SchedulingStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllocationRequest_SchedulingStrategy_descriptor(), enum_t_value);
}
inline bool AllocationRequest_SchedulingStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllocationRequest_SchedulingStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllocationRequest_SchedulingStrategy>(
    AllocationRequest_SchedulingStrategy_descriptor(), name, value);
}
// ===================================================================

class AllocationRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.AllocationRequest) */ {
 public:
  inline AllocationRequest() : AllocationRequest(nullptr) {}
  virtual ~AllocationRequest();

  AllocationRequest(const AllocationRequest& from);
  AllocationRequest(AllocationRequest&& from) noexcept
    : AllocationRequest() {
    *this = ::std::move(from);
  }

  inline AllocationRequest& operator=(const AllocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationRequest& operator=(AllocationRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllocationRequest& default_instance();

  static inline const AllocationRequest* internal_default_instance() {
    return reinterpret_cast<const AllocationRequest*>(
               &_AllocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AllocationRequest& a, AllocationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocationRequest* New() const final {
    return CreateMaybeMessage<AllocationRequest>(nullptr);
  }

  AllocationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocationRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllocationRequest& from);
  void MergeFrom(const AllocationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.AllocationRequest";
  }
  protected:
  explicit AllocationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AllocationRequest_SchedulingStrategy SchedulingStrategy;
  static constexpr SchedulingStrategy Packed =
    AllocationRequest_SchedulingStrategy_Packed;
  static constexpr SchedulingStrategy Distributed =
    AllocationRequest_SchedulingStrategy_Distributed;
  static inline bool SchedulingStrategy_IsValid(int value) {
    return AllocationRequest_SchedulingStrategy_IsValid(value);
  }
  static constexpr SchedulingStrategy SchedulingStrategy_MIN =
    AllocationRequest_SchedulingStrategy_SchedulingStrategy_MIN;
  static constexpr SchedulingStrategy SchedulingStrategy_MAX =
    AllocationRequest_SchedulingStrategy_SchedulingStrategy_MAX;
  static constexpr int SchedulingStrategy_ARRAYSIZE =
    AllocationRequest_SchedulingStrategy_SchedulingStrategy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SchedulingStrategy_descriptor() {
    return AllocationRequest_SchedulingStrategy_descriptor();
  }
  template<typename T>
  static inline const std::string& SchedulingStrategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SchedulingStrategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SchedulingStrategy_Name.");
    return AllocationRequest_SchedulingStrategy_Name(enum_t_value);
  }
  static inline bool SchedulingStrategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SchedulingStrategy* value) {
    return AllocationRequest_SchedulingStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPreferredGameServerSelectorsFieldNumber = 4,
    kNamespaceFieldNumber = 1,
    kMultiClusterSettingFieldNumber = 2,
    kRequiredGameServerSelectorFieldNumber = 3,
    kMetaPatchFieldNumber = 6,
    kSchedulingFieldNumber = 5,
  };
  // repeated .allocation.LabelSelector preferredGameServerSelectors = 4;
  int preferredgameserverselectors_size() const;
  private:
  int _internal_preferredgameserverselectors_size() const;
  public:
  void clear_preferredgameserverselectors();
  ::allocation::LabelSelector* mutable_preferredgameserverselectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::LabelSelector >*
      mutable_preferredgameserverselectors();
  private:
  const ::allocation::LabelSelector& _internal_preferredgameserverselectors(int index) const;
  ::allocation::LabelSelector* _internal_add_preferredgameserverselectors();
  public:
  const ::allocation::LabelSelector& preferredgameserverselectors(int index) const;
  ::allocation::LabelSelector* add_preferredgameserverselectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::LabelSelector >&
      preferredgameserverselectors() const;

  // string namespace = 1;
  void clear_namespace_();
  const std::string& namespace_() const;
  void set_namespace_(const std::string& value);
  void set_namespace_(std::string&& value);
  void set_namespace_(const char* value);
  void set_namespace_(const char* value, size_t size);
  std::string* mutable_namespace_();
  std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // .allocation.MultiClusterSetting multiClusterSetting = 2;
  bool has_multiclustersetting() const;
  private:
  bool _internal_has_multiclustersetting() const;
  public:
  void clear_multiclustersetting();
  const ::allocation::MultiClusterSetting& multiclustersetting() const;
  ::allocation::MultiClusterSetting* release_multiclustersetting();
  ::allocation::MultiClusterSetting* mutable_multiclustersetting();
  void set_allocated_multiclustersetting(::allocation::MultiClusterSetting* multiclustersetting);
  private:
  const ::allocation::MultiClusterSetting& _internal_multiclustersetting() const;
  ::allocation::MultiClusterSetting* _internal_mutable_multiclustersetting();
  public:
  void unsafe_arena_set_allocated_multiclustersetting(
      ::allocation::MultiClusterSetting* multiclustersetting);
  ::allocation::MultiClusterSetting* unsafe_arena_release_multiclustersetting();

  // .allocation.LabelSelector requiredGameServerSelector = 3;
  bool has_requiredgameserverselector() const;
  private:
  bool _internal_has_requiredgameserverselector() const;
  public:
  void clear_requiredgameserverselector();
  const ::allocation::LabelSelector& requiredgameserverselector() const;
  ::allocation::LabelSelector* release_requiredgameserverselector();
  ::allocation::LabelSelector* mutable_requiredgameserverselector();
  void set_allocated_requiredgameserverselector(::allocation::LabelSelector* requiredgameserverselector);
  private:
  const ::allocation::LabelSelector& _internal_requiredgameserverselector() const;
  ::allocation::LabelSelector* _internal_mutable_requiredgameserverselector();
  public:
  void unsafe_arena_set_allocated_requiredgameserverselector(
      ::allocation::LabelSelector* requiredgameserverselector);
  ::allocation::LabelSelector* unsafe_arena_release_requiredgameserverselector();

  // .allocation.MetaPatch metaPatch = 6;
  bool has_metapatch() const;
  private:
  bool _internal_has_metapatch() const;
  public:
  void clear_metapatch();
  const ::allocation::MetaPatch& metapatch() const;
  ::allocation::MetaPatch* release_metapatch();
  ::allocation::MetaPatch* mutable_metapatch();
  void set_allocated_metapatch(::allocation::MetaPatch* metapatch);
  private:
  const ::allocation::MetaPatch& _internal_metapatch() const;
  ::allocation::MetaPatch* _internal_mutable_metapatch();
  public:
  void unsafe_arena_set_allocated_metapatch(
      ::allocation::MetaPatch* metapatch);
  ::allocation::MetaPatch* unsafe_arena_release_metapatch();

  // .allocation.AllocationRequest.SchedulingStrategy scheduling = 5;
  void clear_scheduling();
  ::allocation::AllocationRequest_SchedulingStrategy scheduling() const;
  void set_scheduling(::allocation::AllocationRequest_SchedulingStrategy value);
  private:
  ::allocation::AllocationRequest_SchedulingStrategy _internal_scheduling() const;
  void _internal_set_scheduling(::allocation::AllocationRequest_SchedulingStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:allocation.AllocationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::LabelSelector > preferredgameserverselectors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::allocation::MultiClusterSetting* multiclustersetting_;
  ::allocation::LabelSelector* requiredgameserverselector_;
  ::allocation::MetaPatch* metapatch_;
  int scheduling_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// -------------------------------------------------------------------

class AllocationResponse_GameServerStatusPort PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.AllocationResponse.GameServerStatusPort) */ {
 public:
  inline AllocationResponse_GameServerStatusPort() : AllocationResponse_GameServerStatusPort(nullptr) {}
  virtual ~AllocationResponse_GameServerStatusPort();

  AllocationResponse_GameServerStatusPort(const AllocationResponse_GameServerStatusPort& from);
  AllocationResponse_GameServerStatusPort(AllocationResponse_GameServerStatusPort&& from) noexcept
    : AllocationResponse_GameServerStatusPort() {
    *this = ::std::move(from);
  }

  inline AllocationResponse_GameServerStatusPort& operator=(const AllocationResponse_GameServerStatusPort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationResponse_GameServerStatusPort& operator=(AllocationResponse_GameServerStatusPort&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllocationResponse_GameServerStatusPort& default_instance();

  static inline const AllocationResponse_GameServerStatusPort* internal_default_instance() {
    return reinterpret_cast<const AllocationResponse_GameServerStatusPort*>(
               &_AllocationResponse_GameServerStatusPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllocationResponse_GameServerStatusPort& a, AllocationResponse_GameServerStatusPort& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationResponse_GameServerStatusPort* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationResponse_GameServerStatusPort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocationResponse_GameServerStatusPort* New() const final {
    return CreateMaybeMessage<AllocationResponse_GameServerStatusPort>(nullptr);
  }

  AllocationResponse_GameServerStatusPort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocationResponse_GameServerStatusPort>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllocationResponse_GameServerStatusPort& from);
  void MergeFrom(const AllocationResponse_GameServerStatusPort& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocationResponse_GameServerStatusPort* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.AllocationResponse.GameServerStatusPort";
  }
  protected:
  explicit AllocationResponse_GameServerStatusPort(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 port = 2;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:allocation.AllocationResponse.GameServerStatusPort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// -------------------------------------------------------------------

class AllocationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.AllocationResponse) */ {
 public:
  inline AllocationResponse() : AllocationResponse(nullptr) {}
  virtual ~AllocationResponse();

  AllocationResponse(const AllocationResponse& from);
  AllocationResponse(AllocationResponse&& from) noexcept
    : AllocationResponse() {
    *this = ::std::move(from);
  }

  inline AllocationResponse& operator=(const AllocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocationResponse& operator=(AllocationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllocationResponse& default_instance();

  static inline const AllocationResponse* internal_default_instance() {
    return reinterpret_cast<const AllocationResponse*>(
               &_AllocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AllocationResponse& a, AllocationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AllocationResponse* New() const final {
    return CreateMaybeMessage<AllocationResponse>(nullptr);
  }

  AllocationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllocationResponse& from);
  void MergeFrom(const AllocationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.AllocationResponse";
  }
  protected:
  explicit AllocationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AllocationResponse_GameServerStatusPort GameServerStatusPort;

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 3,
    kGameServerNameFieldNumber = 2,
    kAddressFieldNumber = 4,
    kNodeNameFieldNumber = 5,
  };
  // repeated .allocation.AllocationResponse.GameServerStatusPort ports = 3;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::allocation::AllocationResponse_GameServerStatusPort* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::AllocationResponse_GameServerStatusPort >*
      mutable_ports();
  private:
  const ::allocation::AllocationResponse_GameServerStatusPort& _internal_ports(int index) const;
  ::allocation::AllocationResponse_GameServerStatusPort* _internal_add_ports();
  public:
  const ::allocation::AllocationResponse_GameServerStatusPort& ports(int index) const;
  ::allocation::AllocationResponse_GameServerStatusPort* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::AllocationResponse_GameServerStatusPort >&
      ports() const;

  // string gameServerName = 2;
  void clear_gameservername();
  const std::string& gameservername() const;
  void set_gameservername(const std::string& value);
  void set_gameservername(std::string&& value);
  void set_gameservername(const char* value);
  void set_gameservername(const char* value, size_t size);
  std::string* mutable_gameservername();
  std::string* release_gameservername();
  void set_allocated_gameservername(std::string* gameservername);
  private:
  const std::string& _internal_gameservername() const;
  void _internal_set_gameservername(const std::string& value);
  std::string* _internal_mutable_gameservername();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string nodeName = 5;
  void clear_nodename();
  const std::string& nodename() const;
  void set_nodename(const std::string& value);
  void set_nodename(std::string&& value);
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  std::string* mutable_nodename();
  std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // @@protoc_insertion_point(class_scope:allocation.AllocationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::AllocationResponse_GameServerStatusPort > ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameservername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// -------------------------------------------------------------------

class MultiClusterSetting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.MultiClusterSetting) */ {
 public:
  inline MultiClusterSetting() : MultiClusterSetting(nullptr) {}
  virtual ~MultiClusterSetting();

  MultiClusterSetting(const MultiClusterSetting& from);
  MultiClusterSetting(MultiClusterSetting&& from) noexcept
    : MultiClusterSetting() {
    *this = ::std::move(from);
  }

  inline MultiClusterSetting& operator=(const MultiClusterSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiClusterSetting& operator=(MultiClusterSetting&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiClusterSetting& default_instance();

  static inline const MultiClusterSetting* internal_default_instance() {
    return reinterpret_cast<const MultiClusterSetting*>(
               &_MultiClusterSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MultiClusterSetting& a, MultiClusterSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiClusterSetting* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiClusterSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiClusterSetting* New() const final {
    return CreateMaybeMessage<MultiClusterSetting>(nullptr);
  }

  MultiClusterSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiClusterSetting>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiClusterSetting& from);
  void MergeFrom(const MultiClusterSetting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiClusterSetting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.MultiClusterSetting";
  }
  protected:
  explicit MultiClusterSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicySelectorFieldNumber = 2,
    kEnabledFieldNumber = 1,
  };
  // .allocation.LabelSelector policySelector = 2;
  bool has_policyselector() const;
  private:
  bool _internal_has_policyselector() const;
  public:
  void clear_policyselector();
  const ::allocation::LabelSelector& policyselector() const;
  ::allocation::LabelSelector* release_policyselector();
  ::allocation::LabelSelector* mutable_policyselector();
  void set_allocated_policyselector(::allocation::LabelSelector* policyselector);
  private:
  const ::allocation::LabelSelector& _internal_policyselector() const;
  ::allocation::LabelSelector* _internal_mutable_policyselector();
  public:
  void unsafe_arena_set_allocated_policyselector(
      ::allocation::LabelSelector* policyselector);
  ::allocation::LabelSelector* unsafe_arena_release_policyselector();

  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:allocation.MultiClusterSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::allocation::LabelSelector* policyselector_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// -------------------------------------------------------------------

class MetaPatch_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaPatch_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaPatch_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MetaPatch_LabelsEntry_DoNotUse();
  explicit MetaPatch_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetaPatch_LabelsEntry_DoNotUse& other);
  static const MetaPatch_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaPatch_LabelsEntry_DoNotUse*>(&_MetaPatch_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.MetaPatch.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.MetaPatch.LabelsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class MetaPatch_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaPatch_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetaPatch_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MetaPatch_AnnotationsEntry_DoNotUse();
  explicit MetaPatch_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetaPatch_AnnotationsEntry_DoNotUse& other);
  static const MetaPatch_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetaPatch_AnnotationsEntry_DoNotUse*>(&_MetaPatch_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.MetaPatch.AnnotationsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.MetaPatch.AnnotationsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class MetaPatch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.MetaPatch) */ {
 public:
  inline MetaPatch() : MetaPatch(nullptr) {}
  virtual ~MetaPatch();

  MetaPatch(const MetaPatch& from);
  MetaPatch(MetaPatch&& from) noexcept
    : MetaPatch() {
    *this = ::std::move(from);
  }

  inline MetaPatch& operator=(const MetaPatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaPatch& operator=(MetaPatch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MetaPatch& default_instance();

  static inline const MetaPatch* internal_default_instance() {
    return reinterpret_cast<const MetaPatch*>(
               &_MetaPatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MetaPatch& a, MetaPatch& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaPatch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaPatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaPatch* New() const final {
    return CreateMaybeMessage<MetaPatch>(nullptr);
  }

  MetaPatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaPatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MetaPatch& from);
  void MergeFrom(const MetaPatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaPatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.MetaPatch";
  }
  protected:
  explicit MetaPatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
    kAnnotationsFieldNumber = 2,
  };
  // map<string, string> labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 2;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // @@protoc_insertion_point(class_scope:allocation.MetaPatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MetaPatch_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MetaPatch_AnnotationsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// -------------------------------------------------------------------

class LabelSelector_MatchLabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LabelSelector_MatchLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LabelSelector_MatchLabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  LabelSelector_MatchLabelsEntry_DoNotUse();
  explicit LabelSelector_MatchLabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LabelSelector_MatchLabelsEntry_DoNotUse& other);
  static const LabelSelector_MatchLabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LabelSelector_MatchLabelsEntry_DoNotUse*>(&_LabelSelector_MatchLabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.LabelSelector.MatchLabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "allocation.LabelSelector.MatchLabelsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class LabelSelector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:allocation.LabelSelector) */ {
 public:
  inline LabelSelector() : LabelSelector(nullptr) {}
  virtual ~LabelSelector();

  LabelSelector(const LabelSelector& from);
  LabelSelector(LabelSelector&& from) noexcept
    : LabelSelector() {
    *this = ::std::move(from);
  }

  inline LabelSelector& operator=(const LabelSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelSelector& operator=(LabelSelector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LabelSelector& default_instance();

  static inline const LabelSelector* internal_default_instance() {
    return reinterpret_cast<const LabelSelector*>(
               &_LabelSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LabelSelector& a, LabelSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelSelector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelSelector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LabelSelector* New() const final {
    return CreateMaybeMessage<LabelSelector>(nullptr);
  }

  LabelSelector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LabelSelector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LabelSelector& from);
  void MergeFrom(const LabelSelector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelSelector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "allocation.LabelSelector";
  }
  protected:
  explicit LabelSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_agones_2fallocation_2eproto);
    return ::descriptor_table_agones_2fallocation_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMatchLabelsFieldNumber = 1,
  };
  // map<string, string> matchLabels = 1;
  int matchlabels_size() const;
  private:
  int _internal_matchlabels_size() const;
  public:
  void clear_matchlabels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_matchlabels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_matchlabels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      matchlabels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_matchlabels();

  // @@protoc_insertion_point(class_scope:allocation.LabelSelector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      LabelSelector_MatchLabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> matchlabels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_agones_2fallocation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AllocationRequest

// string namespace = 1;
inline void AllocationRequest::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& AllocationRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.namespace)
  return _internal_namespace_();
}
inline void AllocationRequest::set_namespace_(const std::string& value) {
  _internal_set_namespace_(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationRequest.namespace)
}
inline std::string* AllocationRequest::mutable_namespace_() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationRequest.namespace)
  return _internal_mutable_namespace_();
}
inline const std::string& AllocationRequest::_internal_namespace_() const {
  return namespace__.Get();
}
inline void AllocationRequest::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AllocationRequest::set_namespace_(std::string&& value) {
  
  namespace__.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:allocation.AllocationRequest.namespace)
}
inline void AllocationRequest::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:allocation.AllocationRequest.namespace)
}
inline void AllocationRequest::set_namespace_(const char* value,
    size_t size) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:allocation.AllocationRequest.namespace)
}
inline std::string* AllocationRequest::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AllocationRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:allocation.AllocationRequest.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllocationRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationRequest.namespace)
}

// .allocation.MultiClusterSetting multiClusterSetting = 2;
inline bool AllocationRequest::_internal_has_multiclustersetting() const {
  return this != internal_default_instance() && multiclustersetting_ != nullptr;
}
inline bool AllocationRequest::has_multiclustersetting() const {
  return _internal_has_multiclustersetting();
}
inline void AllocationRequest::clear_multiclustersetting() {
  if (GetArena() == nullptr && multiclustersetting_ != nullptr) {
    delete multiclustersetting_;
  }
  multiclustersetting_ = nullptr;
}
inline const ::allocation::MultiClusterSetting& AllocationRequest::_internal_multiclustersetting() const {
  const ::allocation::MultiClusterSetting* p = multiclustersetting_;
  return p != nullptr ? *p : reinterpret_cast<const ::allocation::MultiClusterSetting&>(
      ::allocation::_MultiClusterSetting_default_instance_);
}
inline const ::allocation::MultiClusterSetting& AllocationRequest::multiclustersetting() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.multiClusterSetting)
  return _internal_multiclustersetting();
}
inline void AllocationRequest::unsafe_arena_set_allocated_multiclustersetting(
    ::allocation::MultiClusterSetting* multiclustersetting) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multiclustersetting_);
  }
  multiclustersetting_ = multiclustersetting;
  if (multiclustersetting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:allocation.AllocationRequest.multiClusterSetting)
}
inline ::allocation::MultiClusterSetting* AllocationRequest::release_multiclustersetting() {
  
  ::allocation::MultiClusterSetting* temp = multiclustersetting_;
  multiclustersetting_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::allocation::MultiClusterSetting* AllocationRequest::unsafe_arena_release_multiclustersetting() {
  // @@protoc_insertion_point(field_release:allocation.AllocationRequest.multiClusterSetting)
  
  ::allocation::MultiClusterSetting* temp = multiclustersetting_;
  multiclustersetting_ = nullptr;
  return temp;
}
inline ::allocation::MultiClusterSetting* AllocationRequest::_internal_mutable_multiclustersetting() {
  
  if (multiclustersetting_ == nullptr) {
    auto* p = CreateMaybeMessage<::allocation::MultiClusterSetting>(GetArena());
    multiclustersetting_ = p;
  }
  return multiclustersetting_;
}
inline ::allocation::MultiClusterSetting* AllocationRequest::mutable_multiclustersetting() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationRequest.multiClusterSetting)
  return _internal_mutable_multiclustersetting();
}
inline void AllocationRequest::set_allocated_multiclustersetting(::allocation::MultiClusterSetting* multiclustersetting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete multiclustersetting_;
  }
  if (multiclustersetting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(multiclustersetting);
    if (message_arena != submessage_arena) {
      multiclustersetting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiclustersetting, submessage_arena);
    }
    
  } else {
    
  }
  multiclustersetting_ = multiclustersetting;
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationRequest.multiClusterSetting)
}

// .allocation.LabelSelector requiredGameServerSelector = 3;
inline bool AllocationRequest::_internal_has_requiredgameserverselector() const {
  return this != internal_default_instance() && requiredgameserverselector_ != nullptr;
}
inline bool AllocationRequest::has_requiredgameserverselector() const {
  return _internal_has_requiredgameserverselector();
}
inline void AllocationRequest::clear_requiredgameserverselector() {
  if (GetArena() == nullptr && requiredgameserverselector_ != nullptr) {
    delete requiredgameserverselector_;
  }
  requiredgameserverselector_ = nullptr;
}
inline const ::allocation::LabelSelector& AllocationRequest::_internal_requiredgameserverselector() const {
  const ::allocation::LabelSelector* p = requiredgameserverselector_;
  return p != nullptr ? *p : reinterpret_cast<const ::allocation::LabelSelector&>(
      ::allocation::_LabelSelector_default_instance_);
}
inline const ::allocation::LabelSelector& AllocationRequest::requiredgameserverselector() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.requiredGameServerSelector)
  return _internal_requiredgameserverselector();
}
inline void AllocationRequest::unsafe_arena_set_allocated_requiredgameserverselector(
    ::allocation::LabelSelector* requiredgameserverselector) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requiredgameserverselector_);
  }
  requiredgameserverselector_ = requiredgameserverselector;
  if (requiredgameserverselector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:allocation.AllocationRequest.requiredGameServerSelector)
}
inline ::allocation::LabelSelector* AllocationRequest::release_requiredgameserverselector() {
  
  ::allocation::LabelSelector* temp = requiredgameserverselector_;
  requiredgameserverselector_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::allocation::LabelSelector* AllocationRequest::unsafe_arena_release_requiredgameserverselector() {
  // @@protoc_insertion_point(field_release:allocation.AllocationRequest.requiredGameServerSelector)
  
  ::allocation::LabelSelector* temp = requiredgameserverselector_;
  requiredgameserverselector_ = nullptr;
  return temp;
}
inline ::allocation::LabelSelector* AllocationRequest::_internal_mutable_requiredgameserverselector() {
  
  if (requiredgameserverselector_ == nullptr) {
    auto* p = CreateMaybeMessage<::allocation::LabelSelector>(GetArena());
    requiredgameserverselector_ = p;
  }
  return requiredgameserverselector_;
}
inline ::allocation::LabelSelector* AllocationRequest::mutable_requiredgameserverselector() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationRequest.requiredGameServerSelector)
  return _internal_mutable_requiredgameserverselector();
}
inline void AllocationRequest::set_allocated_requiredgameserverselector(::allocation::LabelSelector* requiredgameserverselector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete requiredgameserverselector_;
  }
  if (requiredgameserverselector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(requiredgameserverselector);
    if (message_arena != submessage_arena) {
      requiredgameserverselector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requiredgameserverselector, submessage_arena);
    }
    
  } else {
    
  }
  requiredgameserverselector_ = requiredgameserverselector;
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationRequest.requiredGameServerSelector)
}

// repeated .allocation.LabelSelector preferredGameServerSelectors = 4;
inline int AllocationRequest::_internal_preferredgameserverselectors_size() const {
  return preferredgameserverselectors_.size();
}
inline int AllocationRequest::preferredgameserverselectors_size() const {
  return _internal_preferredgameserverselectors_size();
}
inline void AllocationRequest::clear_preferredgameserverselectors() {
  preferredgameserverselectors_.Clear();
}
inline ::allocation::LabelSelector* AllocationRequest::mutable_preferredgameserverselectors(int index) {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationRequest.preferredGameServerSelectors)
  return preferredgameserverselectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::LabelSelector >*
AllocationRequest::mutable_preferredgameserverselectors() {
  // @@protoc_insertion_point(field_mutable_list:allocation.AllocationRequest.preferredGameServerSelectors)
  return &preferredgameserverselectors_;
}
inline const ::allocation::LabelSelector& AllocationRequest::_internal_preferredgameserverselectors(int index) const {
  return preferredgameserverselectors_.Get(index);
}
inline const ::allocation::LabelSelector& AllocationRequest::preferredgameserverselectors(int index) const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.preferredGameServerSelectors)
  return _internal_preferredgameserverselectors(index);
}
inline ::allocation::LabelSelector* AllocationRequest::_internal_add_preferredgameserverselectors() {
  return preferredgameserverselectors_.Add();
}
inline ::allocation::LabelSelector* AllocationRequest::add_preferredgameserverselectors() {
  // @@protoc_insertion_point(field_add:allocation.AllocationRequest.preferredGameServerSelectors)
  return _internal_add_preferredgameserverselectors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::LabelSelector >&
AllocationRequest::preferredgameserverselectors() const {
  // @@protoc_insertion_point(field_list:allocation.AllocationRequest.preferredGameServerSelectors)
  return preferredgameserverselectors_;
}

// .allocation.AllocationRequest.SchedulingStrategy scheduling = 5;
inline void AllocationRequest::clear_scheduling() {
  scheduling_ = 0;
}
inline ::allocation::AllocationRequest_SchedulingStrategy AllocationRequest::_internal_scheduling() const {
  return static_cast< ::allocation::AllocationRequest_SchedulingStrategy >(scheduling_);
}
inline ::allocation::AllocationRequest_SchedulingStrategy AllocationRequest::scheduling() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.scheduling)
  return _internal_scheduling();
}
inline void AllocationRequest::_internal_set_scheduling(::allocation::AllocationRequest_SchedulingStrategy value) {
  
  scheduling_ = value;
}
inline void AllocationRequest::set_scheduling(::allocation::AllocationRequest_SchedulingStrategy value) {
  _internal_set_scheduling(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationRequest.scheduling)
}

// .allocation.MetaPatch metaPatch = 6;
inline bool AllocationRequest::_internal_has_metapatch() const {
  return this != internal_default_instance() && metapatch_ != nullptr;
}
inline bool AllocationRequest::has_metapatch() const {
  return _internal_has_metapatch();
}
inline void AllocationRequest::clear_metapatch() {
  if (GetArena() == nullptr && metapatch_ != nullptr) {
    delete metapatch_;
  }
  metapatch_ = nullptr;
}
inline const ::allocation::MetaPatch& AllocationRequest::_internal_metapatch() const {
  const ::allocation::MetaPatch* p = metapatch_;
  return p != nullptr ? *p : reinterpret_cast<const ::allocation::MetaPatch&>(
      ::allocation::_MetaPatch_default_instance_);
}
inline const ::allocation::MetaPatch& AllocationRequest::metapatch() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationRequest.metaPatch)
  return _internal_metapatch();
}
inline void AllocationRequest::unsafe_arena_set_allocated_metapatch(
    ::allocation::MetaPatch* metapatch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metapatch_);
  }
  metapatch_ = metapatch;
  if (metapatch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:allocation.AllocationRequest.metaPatch)
}
inline ::allocation::MetaPatch* AllocationRequest::release_metapatch() {
  
  ::allocation::MetaPatch* temp = metapatch_;
  metapatch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::allocation::MetaPatch* AllocationRequest::unsafe_arena_release_metapatch() {
  // @@protoc_insertion_point(field_release:allocation.AllocationRequest.metaPatch)
  
  ::allocation::MetaPatch* temp = metapatch_;
  metapatch_ = nullptr;
  return temp;
}
inline ::allocation::MetaPatch* AllocationRequest::_internal_mutable_metapatch() {
  
  if (metapatch_ == nullptr) {
    auto* p = CreateMaybeMessage<::allocation::MetaPatch>(GetArena());
    metapatch_ = p;
  }
  return metapatch_;
}
inline ::allocation::MetaPatch* AllocationRequest::mutable_metapatch() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationRequest.metaPatch)
  return _internal_mutable_metapatch();
}
inline void AllocationRequest::set_allocated_metapatch(::allocation::MetaPatch* metapatch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metapatch_;
  }
  if (metapatch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metapatch);
    if (message_arena != submessage_arena) {
      metapatch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metapatch, submessage_arena);
    }
    
  } else {
    
  }
  metapatch_ = metapatch;
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationRequest.metaPatch)
}

// -------------------------------------------------------------------

// AllocationResponse_GameServerStatusPort

// string name = 1;
inline void AllocationResponse_GameServerStatusPort::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AllocationResponse_GameServerStatusPort::name() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.GameServerStatusPort.name)
  return _internal_name();
}
inline void AllocationResponse_GameServerStatusPort::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationResponse.GameServerStatusPort.name)
}
inline std::string* AllocationResponse_GameServerStatusPort::mutable_name() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationResponse.GameServerStatusPort.name)
  return _internal_mutable_name();
}
inline const std::string& AllocationResponse_GameServerStatusPort::_internal_name() const {
  return name_.Get();
}
inline void AllocationResponse_GameServerStatusPort::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AllocationResponse_GameServerStatusPort::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:allocation.AllocationResponse.GameServerStatusPort.name)
}
inline void AllocationResponse_GameServerStatusPort::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:allocation.AllocationResponse.GameServerStatusPort.name)
}
inline void AllocationResponse_GameServerStatusPort::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:allocation.AllocationResponse.GameServerStatusPort.name)
}
inline std::string* AllocationResponse_GameServerStatusPort::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AllocationResponse_GameServerStatusPort::release_name() {
  // @@protoc_insertion_point(field_release:allocation.AllocationResponse.GameServerStatusPort.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllocationResponse_GameServerStatusPort::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationResponse.GameServerStatusPort.name)
}

// int32 port = 2;
inline void AllocationResponse_GameServerStatusPort::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AllocationResponse_GameServerStatusPort::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AllocationResponse_GameServerStatusPort::port() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.GameServerStatusPort.port)
  return _internal_port();
}
inline void AllocationResponse_GameServerStatusPort::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void AllocationResponse_GameServerStatusPort::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationResponse.GameServerStatusPort.port)
}

// -------------------------------------------------------------------

// AllocationResponse

// string gameServerName = 2;
inline void AllocationResponse::clear_gameservername() {
  gameservername_.ClearToEmpty();
}
inline const std::string& AllocationResponse::gameservername() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.gameServerName)
  return _internal_gameservername();
}
inline void AllocationResponse::set_gameservername(const std::string& value) {
  _internal_set_gameservername(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationResponse.gameServerName)
}
inline std::string* AllocationResponse::mutable_gameservername() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationResponse.gameServerName)
  return _internal_mutable_gameservername();
}
inline const std::string& AllocationResponse::_internal_gameservername() const {
  return gameservername_.Get();
}
inline void AllocationResponse::_internal_set_gameservername(const std::string& value) {
  
  gameservername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AllocationResponse::set_gameservername(std::string&& value) {
  
  gameservername_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:allocation.AllocationResponse.gameServerName)
}
inline void AllocationResponse::set_gameservername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gameservername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:allocation.AllocationResponse.gameServerName)
}
inline void AllocationResponse::set_gameservername(const char* value,
    size_t size) {
  
  gameservername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:allocation.AllocationResponse.gameServerName)
}
inline std::string* AllocationResponse::_internal_mutable_gameservername() {
  
  return gameservername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AllocationResponse::release_gameservername() {
  // @@protoc_insertion_point(field_release:allocation.AllocationResponse.gameServerName)
  return gameservername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllocationResponse::set_allocated_gameservername(std::string* gameservername) {
  if (gameservername != nullptr) {
    
  } else {
    
  }
  gameservername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameservername,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationResponse.gameServerName)
}

// repeated .allocation.AllocationResponse.GameServerStatusPort ports = 3;
inline int AllocationResponse::_internal_ports_size() const {
  return ports_.size();
}
inline int AllocationResponse::ports_size() const {
  return _internal_ports_size();
}
inline void AllocationResponse::clear_ports() {
  ports_.Clear();
}
inline ::allocation::AllocationResponse_GameServerStatusPort* AllocationResponse::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationResponse.ports)
  return ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::AllocationResponse_GameServerStatusPort >*
AllocationResponse::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:allocation.AllocationResponse.ports)
  return &ports_;
}
inline const ::allocation::AllocationResponse_GameServerStatusPort& AllocationResponse::_internal_ports(int index) const {
  return ports_.Get(index);
}
inline const ::allocation::AllocationResponse_GameServerStatusPort& AllocationResponse::ports(int index) const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.ports)
  return _internal_ports(index);
}
inline ::allocation::AllocationResponse_GameServerStatusPort* AllocationResponse::_internal_add_ports() {
  return ports_.Add();
}
inline ::allocation::AllocationResponse_GameServerStatusPort* AllocationResponse::add_ports() {
  // @@protoc_insertion_point(field_add:allocation.AllocationResponse.ports)
  return _internal_add_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::allocation::AllocationResponse_GameServerStatusPort >&
AllocationResponse::ports() const {
  // @@protoc_insertion_point(field_list:allocation.AllocationResponse.ports)
  return ports_;
}

// string address = 4;
inline void AllocationResponse::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AllocationResponse::address() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.address)
  return _internal_address();
}
inline void AllocationResponse::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationResponse.address)
}
inline std::string* AllocationResponse::mutable_address() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationResponse.address)
  return _internal_mutable_address();
}
inline const std::string& AllocationResponse::_internal_address() const {
  return address_.Get();
}
inline void AllocationResponse::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AllocationResponse::set_address(std::string&& value) {
  
  address_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:allocation.AllocationResponse.address)
}
inline void AllocationResponse::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:allocation.AllocationResponse.address)
}
inline void AllocationResponse::set_address(const char* value,
    size_t size) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:allocation.AllocationResponse.address)
}
inline std::string* AllocationResponse::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AllocationResponse::release_address() {
  // @@protoc_insertion_point(field_release:allocation.AllocationResponse.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllocationResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationResponse.address)
}

// string nodeName = 5;
inline void AllocationResponse::clear_nodename() {
  nodename_.ClearToEmpty();
}
inline const std::string& AllocationResponse::nodename() const {
  // @@protoc_insertion_point(field_get:allocation.AllocationResponse.nodeName)
  return _internal_nodename();
}
inline void AllocationResponse::set_nodename(const std::string& value) {
  _internal_set_nodename(value);
  // @@protoc_insertion_point(field_set:allocation.AllocationResponse.nodeName)
}
inline std::string* AllocationResponse::mutable_nodename() {
  // @@protoc_insertion_point(field_mutable:allocation.AllocationResponse.nodeName)
  return _internal_mutable_nodename();
}
inline const std::string& AllocationResponse::_internal_nodename() const {
  return nodename_.Get();
}
inline void AllocationResponse::_internal_set_nodename(const std::string& value) {
  
  nodename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AllocationResponse::set_nodename(std::string&& value) {
  
  nodename_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:allocation.AllocationResponse.nodeName)
}
inline void AllocationResponse::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:allocation.AllocationResponse.nodeName)
}
inline void AllocationResponse::set_nodename(const char* value,
    size_t size) {
  
  nodename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:allocation.AllocationResponse.nodeName)
}
inline std::string* AllocationResponse::_internal_mutable_nodename() {
  
  return nodename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AllocationResponse::release_nodename() {
  // @@protoc_insertion_point(field_release:allocation.AllocationResponse.nodeName)
  return nodename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AllocationResponse::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    
  } else {
    
  }
  nodename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:allocation.AllocationResponse.nodeName)
}

// -------------------------------------------------------------------

// MultiClusterSetting

// bool enabled = 1;
inline void MultiClusterSetting::clear_enabled() {
  enabled_ = false;
}
inline bool MultiClusterSetting::_internal_enabled() const {
  return enabled_;
}
inline bool MultiClusterSetting::enabled() const {
  // @@protoc_insertion_point(field_get:allocation.MultiClusterSetting.enabled)
  return _internal_enabled();
}
inline void MultiClusterSetting::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void MultiClusterSetting::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:allocation.MultiClusterSetting.enabled)
}

// .allocation.LabelSelector policySelector = 2;
inline bool MultiClusterSetting::_internal_has_policyselector() const {
  return this != internal_default_instance() && policyselector_ != nullptr;
}
inline bool MultiClusterSetting::has_policyselector() const {
  return _internal_has_policyselector();
}
inline void MultiClusterSetting::clear_policyselector() {
  if (GetArena() == nullptr && policyselector_ != nullptr) {
    delete policyselector_;
  }
  policyselector_ = nullptr;
}
inline const ::allocation::LabelSelector& MultiClusterSetting::_internal_policyselector() const {
  const ::allocation::LabelSelector* p = policyselector_;
  return p != nullptr ? *p : reinterpret_cast<const ::allocation::LabelSelector&>(
      ::allocation::_LabelSelector_default_instance_);
}
inline const ::allocation::LabelSelector& MultiClusterSetting::policyselector() const {
  // @@protoc_insertion_point(field_get:allocation.MultiClusterSetting.policySelector)
  return _internal_policyselector();
}
inline void MultiClusterSetting::unsafe_arena_set_allocated_policyselector(
    ::allocation::LabelSelector* policyselector) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(policyselector_);
  }
  policyselector_ = policyselector;
  if (policyselector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:allocation.MultiClusterSetting.policySelector)
}
inline ::allocation::LabelSelector* MultiClusterSetting::release_policyselector() {
  
  ::allocation::LabelSelector* temp = policyselector_;
  policyselector_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::allocation::LabelSelector* MultiClusterSetting::unsafe_arena_release_policyselector() {
  // @@protoc_insertion_point(field_release:allocation.MultiClusterSetting.policySelector)
  
  ::allocation::LabelSelector* temp = policyselector_;
  policyselector_ = nullptr;
  return temp;
}
inline ::allocation::LabelSelector* MultiClusterSetting::_internal_mutable_policyselector() {
  
  if (policyselector_ == nullptr) {
    auto* p = CreateMaybeMessage<::allocation::LabelSelector>(GetArena());
    policyselector_ = p;
  }
  return policyselector_;
}
inline ::allocation::LabelSelector* MultiClusterSetting::mutable_policyselector() {
  // @@protoc_insertion_point(field_mutable:allocation.MultiClusterSetting.policySelector)
  return _internal_mutable_policyselector();
}
inline void MultiClusterSetting::set_allocated_policyselector(::allocation::LabelSelector* policyselector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete policyselector_;
  }
  if (policyselector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(policyselector);
    if (message_arena != submessage_arena) {
      policyselector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policyselector, submessage_arena);
    }
    
  } else {
    
  }
  policyselector_ = policyselector;
  // @@protoc_insertion_point(field_set_allocated:allocation.MultiClusterSetting.policySelector)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetaPatch

// map<string, string> labels = 1;
inline int MetaPatch::_internal_labels_size() const {
  return labels_.size();
}
inline int MetaPatch::labels_size() const {
  return _internal_labels_size();
}
inline void MetaPatch::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaPatch::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaPatch::labels() const {
  // @@protoc_insertion_point(field_map:allocation.MetaPatch.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaPatch::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaPatch::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:allocation.MetaPatch.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 2;
inline int MetaPatch::_internal_annotations_size() const {
  return annotations_.size();
}
inline int MetaPatch::annotations_size() const {
  return _internal_annotations_size();
}
inline void MetaPatch::clear_annotations() {
  annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaPatch::_internal_annotations() const {
  return annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetaPatch::annotations() const {
  // @@protoc_insertion_point(field_map:allocation.MetaPatch.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaPatch::_internal_mutable_annotations() {
  return annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetaPatch::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:allocation.MetaPatch.annotations)
  return _internal_mutable_annotations();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LabelSelector

// map<string, string> matchLabels = 1;
inline int LabelSelector::_internal_matchlabels_size() const {
  return matchlabels_.size();
}
inline int LabelSelector::matchlabels_size() const {
  return _internal_matchlabels_size();
}
inline void LabelSelector::clear_matchlabels() {
  matchlabels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LabelSelector::_internal_matchlabels() const {
  return matchlabels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LabelSelector::matchlabels() const {
  // @@protoc_insertion_point(field_map:allocation.LabelSelector.matchLabels)
  return _internal_matchlabels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LabelSelector::_internal_mutable_matchlabels() {
  return matchlabels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LabelSelector::mutable_matchlabels() {
  // @@protoc_insertion_point(field_mutable_map:allocation.LabelSelector.matchLabels)
  return _internal_mutable_matchlabels();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace allocation

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::allocation::AllocationRequest_SchedulingStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::allocation::AllocationRequest_SchedulingStrategy>() {
  return ::allocation::AllocationRequest_SchedulingStrategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_agones_2fallocation_2eproto
